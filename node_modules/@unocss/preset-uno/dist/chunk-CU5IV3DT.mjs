import {
  __export
} from "./chunk-YI4MPAID.mjs";

// src/rules/transition.ts
var transitionBasicProps = [
  "color",
  "border-color",
  "background-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow"
];
var transitionPositionProps = [
  "backround-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position"
];
var transitionSizeProps = [
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing"
];
var transitionSwitchProps = ["all", "none"];
var transitionEnhanceProps = ["stroke", "filter", "backdrop-filter", "fill", "mask", "mask-size", "mask-border", "clip-path", "clip"];
var transitionProps = [
  ...transitionBasicProps,
  ...transitionPositionProps,
  ...transitionSizeProps,
  ...transitionEnhanceProps
];
var transitionPropsStr = transitionProps.join(", ");
var validateProperty = (prop) => {
  if (prop && ![...transitionProps, ...transitionSwitchProps].includes(prop))
    return;
  return prop || transitionPropsStr;
};
var transitions = [
  [/^transition(?:-([a-z-]+))?(?:-(\d+))?$/, ([, prop, duration = "150"]) => {
    const transitionProperty = validateProperty(prop);
    if (!transitionProperty)
      return;
    return {
      "transition-property": transitionProperty,
      "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)",
      "transition-duration": `${duration}ms`
    };
  }],
  [/^duration-(\d+)$/, ([, duration = "150"]) => {
    return {
      "transition-duration": `${duration}ms`
    };
  }],
  ["ease", { "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)" }],
  ["ease-in", { "transition-timing-function": "cubic-bezier(0.4, 0, 1, 1)" }],
  ["ease-out", { "transition-timing-function": "cubic-bezier(0, 0, 0.2, 1)" }],
  ["ease-in-out", { "transition-timing-function": "cubic-bezier(0.4, 0, 0.2, 1)" }],
  [/^transition-delay-(\d+)$/, ([, v]) => ({ "transition-delay": `${v}ms` })],
  [/^transition-duration-(\d+)$/, ([, v]) => ({ "transition-duration": `${v}ms` })],
  [/^(?:transition-)?property-([a-z-]+)$/, ([, v]) => {
    const transitionProperty = validateProperty(v);
    if (transitionProperty)
      return { "transition-property": transitionProperty };
  }]
];

// src/utils/mappings.ts
var directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  "x": ["-left", "-right"],
  "y": ["-top", "-bottom"],
  "": [""],
  "a": [""]
};
var cornerMap = {
  "t": ["-top-left", "-top-right"],
  "r": ["-top-right", "-bottom-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "l": ["-bottom-left", "-top-left"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""]
};
var xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};

// src/utils/handlers/handlers.ts
var handlers_exports = {};
__export(handlers_exports, {
  bracket: () => bracket,
  cssvar: () => cssvar,
  fraction: () => fraction,
  number: () => number,
  percent: () => percent,
  px: () => px,
  rem: () => rem,
  time: () => time
});
var numberWithUnitRE = /^(-?[0-9.]+)([a-z]*)$/i;
var numberRE = /^(-?[0-9.]+)$/i;
function rem(str) {
  if (str === "auto" || str === "a")
    return "auto";
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  if (unit)
    return str;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return `${num / 4}rem`;
}
function px(str) {
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  if (unit)
    return str;
  const num = parseFloat(n);
  if (!Number.isNaN(num))
    return `${num}px`;
}
function number(str) {
  if (!numberRE.test(str))
    return;
  const num = parseFloat(str);
  if (!Number.isNaN(num))
    return num;
}
function percent(str) {
  if (str.endsWith("%"))
    str = str.slice(0, -1);
  const num = parseFloat(str);
  if (!Number.isNaN(num))
    return `${num / 100}`;
}
function fraction(str) {
  const [left, right] = str.split("/");
  const num = parseFloat(left) / parseFloat(right);
  if (!Number.isNaN(num))
    return `${num * 100}%`;
}
function bracket(str) {
  if (str && str[0] === "[" && str[str.length - 1] === "]")
    return str.slice(1, -1).replace(/_/g, " ");
}
function cssvar(str) {
  if (str.startsWith("$"))
    return `var(--${str.slice(1)})`;
}
function time(str) {
  const duration = Number(str.replace(/(s|ms)$/, ""));
  if (isNaN(duration))
    return;
  if (/ms|s$/.test(str))
    return str;
  return `${str}ms`;
}

// src/utils/handlers/shorthand.ts
var handlersNames = Object.keys(handlers_exports);
var handler = function(str) {
  var _a;
  const s = ((_a = this.__options) == null ? void 0 : _a.sequence) || [];
  this.__options.sequence = [];
  for (const n of s) {
    const res = handlers_exports[n](str);
    if (res)
      return res;
  }
  return void 0;
};
function addProcessor(that, name) {
  if (!that.__options) {
    that.__options = {
      sequence: []
    };
  }
  that.__options.sequence.push(name);
  return that;
}
handlersNames.forEach((i) => {
  Object.defineProperty(handler, i, {
    enumerable: true,
    get() {
      return addProcessor(this, i);
    }
  });
});

// src/rules/color.ts
import { hex2rgba } from "@unocss/core";
var parseColorUtil = (body, theme) => {
  var _a;
  const [main, opacity2] = body.split(/(?:\/|:)/);
  const [name, no = "DEFAULT"] = main.replace(/([a-z])([0-9])/g, "$1-$2").split(/-/g);
  if (!name)
    return;
  let color;
  const bracket2 = handler.bracket(main) || main;
  if (bracket2.startsWith("#"))
    color = bracket2.slice(1);
  if (bracket2.startsWith("hex-"))
    color = bracket2.slice(4);
  if (!color) {
    const colorData = (_a = theme.colors) == null ? void 0 : _a[name];
    if (typeof colorData === "string")
      color = colorData;
    else if (no && colorData)
      color = colorData[no];
  }
  return {
    opacity: opacity2,
    name,
    no,
    color,
    rgba: hex2rgba(color)
  };
};
var colorResolver = (attribute, varName) => ([, body], { theme }) => {
  const data = parseColorUtil(body, theme);
  if (!data)
    return;
  const { opacity: opacity2, color, rgba } = data;
  if (!color)
    return;
  if (rgba) {
    const a = opacity2 ? opacity2[0] === "[" ? handler.bracket.percent(opacity2) : parseFloat(opacity2) / 100 : rgba[3];
    if (a != null && !Number.isNaN(a)) {
      rgba[3] = typeof a === "string" && !a.includes("%") ? parseFloat(a) : a;
      return {
        [attribute]: `rgba(${rgba.join(",")})`
      };
    } else {
      return {
        [`--un-${varName}-opacity`]: 1,
        [attribute]: `rgba(${rgba.slice(0, 3).join(",")},var(--un-${varName}-opacity))`
      };
    }
  } else {
    return {
      [attribute]: color
    };
  }
};
var opacity = [
  [/^op(?:acity)?-?(.+)$/, ([, d]) => ({ opacity: handler.bracket.percent.cssvar(d) })]
];
var textColors = [
  [/^(?:text|color|c)-(.+)$/, colorResolver("color", "text")],
  [/^(?:text|color|c)-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-text-opacity": handler.bracket.percent.cssvar(opacity2) })]
];
var textDecorationColors = [
  [/^underline-(.+)$/, (match, ctx) => {
    const result = colorResolver("text-decoration-color", "line")(match, ctx);
    if (result) {
      return {
        "-webkit-text-decoration-color": result["text-decoration-color"],
        ...result
      };
    }
  }],
  [/^underline-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-line-opacity": handler.bracket.percent(opacity2) })]
];
var textStrokeColors = [
  [/^text-stroke-(.+)$/, colorResolver("-webkit-text-stroke-color", "text-stroke")],
  [/^text-stroke-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-text-stroke-opacity": handler.bracket.percent(opacity2) })]
];
var bgColors = [
  [/^bg-(.+)$/, colorResolver("background-color", "bg")],
  [/^bg-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-bg-opacity": handler.bracket.percent(opacity2) })]
];
var borderColors = [
  [/^(?:border|b)-(.+)$/, colorResolver("border-color", "border")],
  [/^(?:border|b)-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-border-opacity": handler.bracket.percent(opacity2) })]
];
var ringColors = [
  [/^ring-(.+)$/, colorResolver("--un-ring-color", "ring")],
  [/^ring-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-ring-opacity": handler.bracket.percent(opacity2) })]
];
var ringOffsetColors = [
  [/^ring-offset-(.+)$/, colorResolver("--un-ring-offset-color", "ring-offset")],
  [/^ring-offset-op(?:acity)?-?(.+)$/m, ([, opacity2]) => ({ "--un-ring-offset-opacity": handler.bracket.percent(opacity2) })]
];

// src/rules/border.ts
var borderSizes = [
  [/^border$/, handlerBorder],
  [/^(?:border|b)(?:-([^-]+))?$/, handlerBorder],
  [/^(?:border|b)(?:-([^-]+))?(?:-([^-]+))?$/, handlerBorder]
];
var borderRadius = [
  [/^(?:border-)?(?:rounded|rd)$/, handlerRounded],
  [/^(?:border-)?(?:rounded|rd)(?:-([^-]+))?$/, handlerRounded],
  [/^(?:border-)?(?:rounded|rd)(?:-([^-]+))?(?:-([^-]+))?$/, handlerRounded]
];
var borderStyles = [
  ["border-solid", { "border-style": "solid" }],
  ["border-dashed", { "border-style": "dashed" }],
  ["border-dotted", { "border-style": "dotted" }],
  ["border-double", { "border-style": "double" }],
  ["border-none", { "border-style": "none" }]
];
var borders = [
  borderSizes,
  borderColors,
  borderStyles,
  borderRadius
].flat(1);
function handlerBorder([, a, b]) {
  const [d, s = "1"] = directionMap[a] ? [a, b] : ["", a];
  const v = handler.bracket.px(s);
  if (v != null) {
    return [
      ...directionMap[d].map((i) => [`border${i}-width`, v]),
      ["border-style", "solid"]
    ];
  }
}
function handlerRounded([, a, b], { theme }) {
  var _a;
  const [d, s = "DEFAULT"] = cornerMap[a] ? [a, b] : ["", a];
  const v = ((_a = theme.borderRadius) == null ? void 0 : _a[s]) || handler.bracket.fraction.rem(s);
  if (v != null)
    return cornerMap[d].map((i) => [`border${i}-radius`, v]);
}

// src/rules/background.ts
var colorResolver2 = (mode) => ([, body], { theme }) => {
  const data = parseColorUtil(body, theme);
  if (!data)
    return;
  const { opacity: opacity2, color, rgba } = data;
  if (!color)
    return;
  let colorString = color;
  if (rgba) {
    const a = opacity2 ? opacity2[0] === "[" ? handler.bracket.percent(opacity2) : parseFloat(opacity2) / 100 : rgba[3];
    if (a != null && !Number.isNaN(a)) {
      rgba[3] = typeof a === "string" && !a.includes("%") ? parseFloat(a) : a;
      colorString = `rgba(${rgba.join(",")}, var(--un-${mode}-opacity, 1))`;
    } else {
      colorString = `rgba(${rgba.slice(0, 3).join(",")}, var(--un-${mode}-opacity, 1))`;
    }
  }
  switch (mode) {
    case "from":
      return {
        "--un-gradient-from": colorString,
        "--un-gradient-stops": "var(--un-gradient-from), var(--un-gradient-to, rgba(255, 255, 255, 0))"
      };
    case "via":
      return {
        "--un-gradient-stops": `var(--un-gradient-from), ${colorString}, var(--un-gradient-to, rgba(255, 255, 255, 0))`
      };
    case "to":
      return {
        "--un-gradient-to": colorString
      };
  }
};
var bgAttachments = [
  ["bg-fixed", { "background-attachment": "fixed" }],
  ["bg-local", { "background-attachment": "local" }],
  ["bg-scroll", { "background-attachment": "scroll" }]
];
var bgBlendModes = [
  ["bg-blend-normal", { "background-blend-mode": "normal" }],
  ["bg-blend-multiply", { "background-blend-mode": "multiply" }],
  ["bg-blend-screen", { "background-blend-mode": "screen" }],
  ["bg-blend-overlay", { "background-blend-mode": "overlay" }],
  ["bg-blend-darken", { "background-blend-mode": "darken" }],
  ["bg-blend-lighten", { "background-blend-mode": "lighten" }],
  ["bg-blend-color-dodge", { "background-blend-mode": "color-dodge" }],
  ["bg-blend-color-burn", { "background-blend-mode": "color-burn" }],
  ["bg-blend-hard-light", { "background-blend-mode": "hard-light" }],
  ["bg-blend-soft-light", { "background-blend-mode": "soft-light" }],
  ["bg-blend-difference", { "background-blend-mode": "difference" }],
  ["bg-blend-exclusion", { "background-blend-mode": "exclusion" }],
  ["bg-blend-hue", { "background-blend-mode": "hue" }],
  ["bg-blend-saturation", { "background-blend-mode": "saturation" }],
  ["bg-blend-color", { "background-blend-mode": "color" }],
  ["bg-blend-luminosity", { "background-blend-mode": "luminosity" }]
];
var bgClips = [
  ["bg-clip-border", { "-webkit-background-clip": "border-box", "background-attachment": "border-box" }],
  ["bg-clip-content", { "-webkit-background-clip": "content-box", "background-attachment": "content-box" }],
  ["bg-clip-padding", { "-webkit-background-clip": "padding-box", "background-attachment": "padding-box" }],
  ["bg-clip-text", { "-webkit-background-clip": "text", "background-attachment": "text" }]
];
var bgGradients = [
  [/^from-(.+)$/, colorResolver2("from")],
  [/^to-(.+)$/, colorResolver2("to")],
  [/^via-(.+)$/, colorResolver2("via")]
];
var bgImages = [
  ["bg-none", { "background-image": "none" }],
  ["bg-gradient-to-t", {
    "background-image": "linear-gradient(to top, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-tr", {
    "background-image": "linear-gradient(to top right, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-r", {
    "background-image": "linear-gradient(to right, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-br", {
    "background-image": "linear-gradient(to bottom right, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-b", {
    "background-image": "linear-gradient(to bottom, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-bl", {
    "background-image": "linear-gradient(to bottom left, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-l", {
    "background-image": "linear-gradient(to left, var(--un-gradient-stops))"
  }],
  ["bg-gradient-to-tl", {
    "background-image": "linear-gradient(to top left, var(--un-gradient-stops))"
  }]
];
var bgOrigins = [
  ["bg-origin-border", { "background-origin": "border-box" }],
  ["bg-origin-padding", { "background-origin": "padding-box" }],
  ["bg-origin-content", { "background-origin": "content-box" }]
];
var bgPositions = [
  ["bg-bottom", { "background-position": "bottom" }],
  ["bg-center", { "background-position": "center" }],
  ["bg-left", { "background-position": "left" }],
  ["bg-left-bottom", { "background-position": "left bottom" }],
  ["bg-left-top", { "background-position": "left top" }],
  ["bg-right", { "background-position": "right" }],
  ["bg-right-bottom", { "background-position": "right bottom" }],
  ["bg-right-top", { "background-position": "right top" }],
  ["bg-top", { "background-position": "top" }]
];
var bgRepeats = [
  ["bg-repeat", { "background-repeat": "repeat" }],
  ["bg-no-repeat", { "background-repeat": "no-repeat" }],
  ["bg-repeat-x", { "background-position": "repeat-x" }],
  ["bg-repeat-y", { "background-position": "repeat-y" }],
  ["bg-repeat-round", { "background-position": "round" }],
  ["bg-repeat-space", { "background-position": "space" }]
];
var bgSizes = [
  ["bg-auto", { "background-size": "auto" }],
  ["bg-cover", { "background-repeat": "cover" }],
  ["bg-contain", { "background-position": "contain" }]
];

// src/rules/filters.ts
import { toArray } from "@unocss/core";
var varEmpty = "var(--un-empty,/*!*/ /*!*/)";
var percentWithDefault = (defaultValue = "1") => (str) => {
  const v = str ? handler.bracket.percent(str) : defaultValue;
  return v && parseFloat(v) <= 1 ? v : void 0;
};
var toFilter = (varName, resolver) => ([, b, s], { theme }) => {
  const value = resolver(s, theme);
  if (value)
    return { [`--un-${b || ""}${varName}`]: `${varName}(${value})` };
};
var filterContnet = "var(--un-blur) var(--un-brightness) var(--un-contrast) var(--un-grayscale) var(--un-hue-rotate) var(--un-invert) var(--un-saturate) var(--un-sepia) var(--un-drop-shadow)";
var filter = {
  "--un-blur": varEmpty,
  "--un-brightness": varEmpty,
  "--un-contrast": varEmpty,
  "--un-grayscale": varEmpty,
  "--un-hue-rotate": varEmpty,
  "--un-invert": varEmpty,
  "--un-saturate": varEmpty,
  "--un-sepia": varEmpty,
  "--un-drop-shadow": varEmpty,
  "filter": filterContnet
};
var backdropFilterContent = "var(--un-backdrop-blur) var(--un-backdrop-brightness) var(--un-backdrop-contrast) var(--un-backdrop-grayscale) var(--un-backdrop-hue-rotate) var(--un-backdrop-invert) var(--un-backdrop-saturate) var(--un-backdrop-sepia)";
var backdropFilter = {
  "--un-backdrop-blur": varEmpty,
  "--un-backdrop-brightness": varEmpty,
  "--un-backdrop-contrast": varEmpty,
  "--un-backdrop-grayscale": varEmpty,
  "--un-backdrop-hue-rotate": varEmpty,
  "--un-backdrop-invert": varEmpty,
  "--un-backdrop-saturate": varEmpty,
  "--un-backdrop-sepia": varEmpty,
  "-webkit-backdrop-filter": backdropFilterContent,
  "backdrop-filter": backdropFilterContent
};
var filters = [
  ["filter", filter],
  ["filter-none", { filter: "none" }],
  ["backdrop-filter", backdropFilter],
  ["backdrop-filter-none", {
    "-webkit-backdrop-filter": "none",
    "backdrop-filter": "none"
  }],
  [/^(backdrop-)?blur(?:-(.+))?$/, toFilter("blur", (s, theme) => {
    var _a;
    return ((_a = theme.blur) == null ? void 0 : _a[s || "DEFAULT"]) || handler.bracket.px(s);
  })],
  [/^(backdrop-)?brightness-(\d+)$/, toFilter("brightness", (s) => handler.bracket.percent(s))],
  [/^(backdrop-)?contrast-(\d+)$/, toFilter("contrast", (s) => handler.bracket.percent(s))],
  [/^()?drop-shadow(?:-(.+))?$/, toFilter("drop-shadow", (s, theme) => {
    var _a;
    const v = handler.bracket(s) || ((_a = theme.dropShadow) == null ? void 0 : _a[s || "DEFAULT"]);
    if (v)
      return toArray(v).map((v2) => `drop-shadow(${v2})`).join(" ");
  })],
  [/^(backdrop-)?grayscale(?:-(\d+))?$/, toFilter("grayscale", percentWithDefault())],
  [/^(backdrop-)?hue-rotate-(\d+)$/, toFilter("hue-rotate", (s) => `${handler.bracket.number(s)}deg`)],
  [/^(backdrop-)?invert(?:-(\d+))?$/, toFilter("invert", percentWithDefault())],
  [/^(backdrop-)?saturate(?:-(\d+))?$/, toFilter("saturate", percentWithDefault("0"))],
  [/^(backdrop-)?sepia(?:-(\d+))?$/, toFilter("sepia", percentWithDefault())]
];

// src/rules/flex.ts
var flex = [
  ["flex-col", { "flex-direction": "column" }],
  ["flex-col-reverse", { "flex-direction": "column-reverse" }],
  ["flex-row", { "flex-direction": "row" }],
  ["flex-row-reverse", { "flex-direction": "row-reverse" }],
  ["flex-wrap", { "flex-wrap": "wrap" }],
  ["flex-wrap-reverse", { "flex-wrap": "wrap-reverse" }],
  ["flex-nowrap", { "flex-wrap": "nowrap" }],
  ["flex-1", { flex: "1 1 0%" }],
  ["flex-auto", { flex: "1 1 auto" }],
  ["flex-initial", { flex: "0 1 auto" }],
  ["flex-none", { flex: "none" }],
  [/^flex-\[(.+)\]$/, ([, d]) => ({ flex: d })],
  ["flex-grow", { "flex-grow": 1 }],
  ["flex-grow-0", { "flex-grow": 0 }],
  ["flex-shrink", { "flex-shrink": 1 }],
  ["flex-shrink-0", { "flex-shrink": 0 }],
  ["flex", { display: "flex" }],
  ["inline-flex", { display: "inline-flex" }]
];

// src/rules/typography.ts
import { toArray as toArray2 } from "@unocss/core";
var fontsFamilies = [
  [/^font-(\w+)$/, ([, d], { theme }) => {
    var _a;
    const font = (_a = theme.fontFamily) == null ? void 0 : _a[d];
    if (font) {
      return {
        "font-family": font
      };
    }
  }]
];
var weightMap = {
  thin: "100",
  extralight: "200",
  light: "300",
  normal: "400",
  medium: "500",
  semibold: "600",
  bold: "700",
  extrabold: "800",
  black: "900"
};
var fontSizes = [
  [/^text-([^-]+)$/, ([, s = "base"], { theme }) => {
    var _a;
    const result = toArray2(((_a = theme.fontSize) == null ? void 0 : _a[s]) || handler.bracket.rem(s));
    if (result == null ? void 0 : result[0]) {
      const [size, height = "1"] = result;
      return {
        "font-size": size,
        "line-height": height
      };
    }
  }]
];
var fontWeights = [
  [/^(?:font|fw)-?([^-]+)$/, ([, s]) => {
    const v = weightMap[s] || handler.number(s);
    if (v)
      return { "font-weight": v };
  }]
];
var leadings = [
  [/^(?:leading|lh)-([^-]+)$/, ([, s], { theme }) => {
    var _a;
    const v = ((_a = theme.lineHeight) == null ? void 0 : _a[s]) || handler.bracket.rem(s);
    if (v !== null)
      return { "line-height": v };
  }]
];
var trackings = [
  [/^tracking-([^-]+)$/, ([, s], { theme }) => {
    var _a;
    const v = ((_a = theme.letterSpacing) == null ? void 0 : _a[s]) || handler.bracket.rem(s);
    if (v !== null)
      return { "letter-spacing": v };
  }]
];
var tabSizes = [
  [/^tab-?([^-]*)$/, ([, s]) => {
    const v = handler.bracket.number.rem(s) || 4;
    return {
      "-moz-tab-size": v,
      "-o-tab-size": v,
      "tab-size": v
    };
  }]
];
var textDecorationLengths = [
  [/^underline-([^-]+)$/, ([, s]) => {
    const v = s === "auto" ? s : handler.bracket.px(s);
    if (v != null)
      return { "text-decoration-thickness": v };
  }]
];
var textDecorationOffsets = [
  [/^underline-offset-([^-]+)$/, ([, s]) => {
    const v = s === "auto" ? s : handler.bracket.px(s);
    if (v != null)
      return { "text-underline-offset": v };
  }]
];
var textIndents = [
  [/^indent-?([^-]*)$/, ([, s], { theme }) => {
    var _a;
    const v = ((_a = theme.textIndent) == null ? void 0 : _a[s || "DEFAULT"]) || handler.bracket.fraction.rem(s);
    if (v != null)
      return { "text-indent": v };
  }]
];
var textStrokeWidths = [
  [/^text-stroke-?([^-]*)$/, ([, s], { theme }) => {
    var _a;
    const v = ((_a = theme.textStrokeWidth) == null ? void 0 : _a[s || "DEFAULT"]) || handler.bracket.px(s);
    if (v != null)
      return { "-webkit-text-stroke-width": v };
  }]
];
var fonts = [
  fontsFamilies,
  fontSizes,
  fontWeights
].flat(1);

// src/rules/gap.ts
var gaps = [
  [/^(?:flex-|grid-)?gap-([^-]+)$/, ([, s]) => {
    const v = handler.bracket.rem(s);
    if (v != null) {
      return {
        "grid-gap": v,
        "gap": v
      };
    }
  }],
  [/^(?:flex-|grid-)?gap-x-([^-]+)$/, ([, s]) => {
    const v = handler.bracket.rem(s);
    if (v != null) {
      return {
        "grid-column-gap": v,
        "column-gap": v
      };
    }
  }],
  [/^(?:flex-|grid-)?gap-y-([^-]+)$/, ([, s]) => {
    const v = handler.bracket.rem(s);
    if (v != null) {
      return {
        "grid-row-gap": v,
        "row-gap": v
      };
    }
  }]
];

// src/rules/grid.ts
import { toArray as toArray3 } from "@unocss/core";
var calSize = (s, theme) => {
  var _a;
  return toArray3(((_a = theme.fontSize) == null ? void 0 : _a[s]) || handler.bracket.rem(s))[0];
};
var isNumber = (s) => !isNaN(Number(s));
var autoDirection = (selector, theme) => {
  if (selector === "min")
    return "min-content";
  else if (selector === "max")
    return "max-content";
  else if (selector === "fr")
    return "minmax(0, 1fr)";
  return calSize(selector, theme);
};
var grids = [
  ["grid", { display: "grid" }],
  ["inline-grid", { display: "inline-grid" }],
  [/^grid-cols-(\d+)$/, ([, d]) => ({ "grid-template-columns": `repeat(${d}, minmax(0, 1fr))` })],
  [/^grid-rows-(\d+)$/, ([, d]) => ({ "grid-template-rows": `repeat(${d}, minmax(0, 1fr))` })],
  [/^grid-cols-\[(.+)\]$/, ([, v]) => ({ "grid-template-columns": v.replace(/,/g, " ") })],
  [/^grid-rows-\[(.+)\]$/, ([, v]) => ({ "grid-template-rows": v.replace(/,/g, " ") })],
  [/^(?:grid-)?auto-flow-(.+)$/, ([, v]) => ({ "grid-auto-flow": `${v.replace("col", "column").split("-").join(" ")}` })],
  [/^(?:grid-)?row-start-(.+)$/, ([, v]) => ({ "grid-row-start": `${v}` })],
  [/^(?:grid-)?row-end-(.+)$/, ([, v]) => ({ "grid-row-end": `${v}` })],
  [/^(?:grid-)?col-start-(.+)$/, ([, v]) => ({ "grid-column-start": `${v}` })],
  [/^(?:grid-)?col-end-(.+)$/, ([, v]) => ({ "grid-column-end": `${v}` })],
  [/^(?:grid-)?auto-rows-(.+)$/, ([, v], { theme }) => ({ "grid-auto-rows": `${autoDirection(v, theme)}` })],
  [/^(?:grid-)?auto-cols-(.+)$/, ([, v], { theme }) => ({ "grid-auto-columns": `${autoDirection(v, theme)}` })],
  [/^(?:grid-)?row-((?!(start)|(end)).+)$/, ([, v]) => {
    const shortArr = v.split("-");
    if (shortArr[0] === "span") {
      if (shortArr[1] === "full") {
        return {
          "grid-row": "1 / -1"
        };
      }
      return isNumber(shortArr[1]) ? { "grid-row": `span ${shortArr[1]} / span ${shortArr[1]}` } : void 0;
    }
    return { "grid-row": v.split("-").join(" ") };
  }],
  [/^(?:grid-)?col-((?!(start)|(end)).+)$/, ([, v]) => {
    const shortArr = v.split("-");
    if (shortArr[0] === "span") {
      if (shortArr[1] === "full") {
        return {
          "grid-column": "1 / -1"
        };
      }
      return isNumber(shortArr[1]) ? { "grid-column": `span ${shortArr[1]} / span ${shortArr[1]}` } : void 0;
    }
    return { "grid-column": v.split("-").join(" ") };
  }]
];

// src/rules/layout.ts
var overflowValues = [
  "auto",
  "hidden",
  "visible",
  "scroll"
];
var overflows = [
  [/^(?:overflow|of)-(.+)$/, ([, v]) => overflowValues.includes(v) ? { overflow: v } : void 0],
  [/^(?:overflow|of)-([xy])-(.+)$/, ([, d, v]) => overflowValues.includes(v) ? { [`overflow-${d}`]: v } : void 0]
];

// src/rules/position.ts
var positions = [
  ["relative", { position: "relative" }],
  ["absolute", { position: "absolute" }],
  ["fixed", { position: "fixed" }]
];
var justifies = [
  ["justify-start", { "justify-content": "flex-start" }],
  ["justify-end", { "justify-content": "flex-end" }],
  ["justify-center", { "justify-content": "center" }],
  ["justify-between", { "justify-content": "space-between" }],
  ["justify-around", { "justify-content": "space-around" }],
  ["justify-evenly", { "justify-content": "space-evenly" }]
];
var orders = [
  [/^order-(.+)$/, ([, v]) => ({ order: { first: "-9999", last: "9999", none: "0" }[v] || handler.bracket.number(v) })]
];
var basicSet = ["auto", "start", "end", "center", "stretch"];
var justifyItems = basicSet.map((i) => [`justify-items-${i}`, { "justify-items": i }]);
var justifySelfs = basicSet.map((i) => [`justify-self-${i}`, { "justify-self": i }]);
var alignContents = [
  ["content-start", { "align-content": "flex-start" }],
  ["content-end", { "align-content": "flex-end" }],
  ["content-center", { "align-content": "center" }],
  ["content-between", { "align-content": "space-between" }],
  ["content-around", { "align-content": "space-around" }],
  ["content-evenly", { "align-content": "space-evenly" }]
];
var alignItems = [
  ["items-start", { "align-items": "flex-start" }],
  ["items-end", { "align-items": "flex-end" }],
  ["items-center", { "align-items": "center" }],
  ["items-baseline", { "align-items": "baseline" }],
  ["items-stretch", { "align-items": "stretch" }]
];
var alignSelfs = [
  ["self-auto", { "align-self": "auto" }],
  ["self-start", { "align-self": "flex-start" }],
  ["self-end", { "align-self": "flex-end" }],
  ["self-center", { "align-self": "center" }],
  ["self-stretch", { "align-items": "stretch" }]
];
var placeContents = [
  ["place-content-start", { "place-content": "start" }],
  ["place-content-end", { "place-content": "end" }],
  ["place-content-center", { "place-content": "center" }],
  ["place-content-between", { "place-content": "space-between" }],
  ["place-content-around", { "place-content": "space-around" }],
  ["place-content-evenly", { "place-content": "space-evenly" }],
  ["place-content-stretch", { "place-content": "stretch" }]
];
var placeItems = basicSet.map((i) => [`place-items-${i}`, { "place-items": i }]);
var placeSelfs = basicSet.map((i) => [`place-self-${i}`, { "place-self": i }]);
function handleInsetValue(v) {
  var _a;
  return (_a = { auto: "auto", full: "100%" }[v]) != null ? _a : handler.bracket.fraction.cssvar.rem(v);
}
var insets = [
  [/^(top|left|right|bottom|inset)-(.+)$/, ([, d, v]) => ({ [d]: handleInsetValue(v) })],
  [/^inset-([xy])-(.+)$/, ([, d, v]) => {
    const r = handleInsetValue(v);
    if (r != null && d in directionMap)
      return directionMap[d].map((i) => [i.slice(1), r]);
  }]
];
var floats = [
  [/^float-(left|right|none)$/, ([, value]) => ({ float: value })],
  [/^clear-(left|right|both|none)$/, ([, value]) => ({ clear: value })]
];
var zIndexes = [
  ["z-auto", { "z-index": "auto" }],
  [/^z-([^-]+)$/, ([, v]) => ({ "z-index": handler.number(v) })]
];
var objectPositions = [
  ["object-cover", { "object-fit": "cover" }],
  ["object-contain", { "object-fit": "contain" }],
  ["object-fill", { "object-fit": "fill" }],
  ["object-scale-down", { "object-fit": "scale-down" }],
  ["object-none", { "object-fit": "none" }],
  ["object-bottom", { "object-position": "bottom" }],
  ["object-top", { "object-position": "top" }],
  ["object-right", { "object-position": "right" }],
  ["object-left", { "object-position": "left" }],
  ["object-lb", { "object-position": "left bottom" }],
  ["object-lt", { "object-position": "left top" }],
  ["object-rb", { "object-position": "right bottom" }],
  ["object-rt", { "object-position": "right top" }]
];
var boxSizing = [
  [
    /^box-(border|content)$/,
    ([, value]) => ({
      "box-sizing": `${value}-box`
    })
  ]
];

// src/rules/ring.ts
var rings = [
  [/^ring-?(.*)$/, ([, d]) => {
    const value = handler.px(d || "1");
    if (value) {
      return {
        "--un-ring-inset": "var(--un-empty, )",
        "--un-ring-offset-width": "0px",
        "--un-ring-offset-color": "#fff",
        "--un-ring-color": "rgba(59, 130, 246, .5)",
        "--un-ring-offset-shadow": "var(--un-ring-inset) 0 0 0 var(--un-ring-offset-width) var(--un-ring-offset-color)",
        "--un-ring-shadow": `var(--un-ring-inset) 0 0 0 calc(${value} + var(--un-ring-offset-width)) var(--un-ring-color)`,
        "-webkit-box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow, 0 0 #0000);",
        "box-shadow": "var(--un-ring-offset-shadow), var(--un-ring-shadow), var(--un-shadow, 0 0 #0000);"
      };
    }
  }],
  [/^ring-offset-?(.*)$/, ([, d]) => {
    const value = handler.px(d || "1");
    if (value) {
      return {
        "--un-ring-offset-width": value
      };
    }
  }],
  ["ring-inset", { "--un-ring-inset": "inset" }],
  ...ringColors,
  ...ringOffsetColors
];

// src/rules/shadow.ts
var colorResolver3 = (body, theme) => {
  const data = parseColorUtil(body, theme);
  if (!data)
    return;
  const { color, rgba } = data;
  if (!color)
    return;
  if (rgba) {
    return {
      "--un-shadow-color": `${rgba.slice(0, 3).join(",")}`
    };
  } else {
    return {
      "--un-shadow-color": color
    };
  }
};
var mixBlendModes = [
  ["mix-blend-normal", { "mix-blend-mode": "normal" }],
  ["mix-blend-multiply", { "mix-blend-mode": "multiply" }],
  ["mix-blend-screen", { "mix-blend-mode": "screen" }],
  ["mix-blend-overlay", { "mix-blend-mode": "overlay" }],
  ["mix-blend-darken", { "mix-blend-mode": "darken" }],
  ["mix-blend-lighten", { "mix-blend-mode": "lighten" }],
  ["mix-blend-color-dodge", { "mix-blend-mode": "color-dodge" }],
  ["mix-blend-color-burn", { "mix-blend-mode": "color-burn" }],
  ["mix-blend-color-light", { "mix-blend-mode": "color-light" }],
  ["mix-blend-soft-light", { "mix-blend-mode": "soft-light" }],
  ["mix-blend-difference", { "mix-blend-mode": "difference" }],
  ["mix-blend-exclusion", { "mix-blend-mode": "exclusion" }],
  ["mix-blend-hue", { "mix-blend-mode": "hue" }],
  ["mix-blend-saturation", { "mix-blend-mode": "saturation" }],
  ["mix-blend-color", { "mix-blend-mode": "color" }],
  ["mix-blend-luminosity", { "mix-blend-mode": "luminosity" }]
];
var shadows = [
  [/^shadow-?(.*)$/, ([, d], { theme }) => {
    var _a;
    const value = (_a = theme == null ? void 0 : theme.textShadow) == null ? void 0 : _a[d || "DEFAULT"];
    if (value) {
      return {
        "--un-shadow-color": "0,0,0",
        "--un-shadow": value,
        "-webkit-box-shadow": "var(--un-ring-offset-shadow, 0 0 #0000), var(--un-ring-shadow, 0 0 #0000), var(--un-shadow)",
        "box-shadow": "var(--un-ring-offset-shadow, 0 0 #0000), var(--un-ring-shadow, 0 0 #0000), var(--un-shadow)"
      };
    }
    const color = colorResolver3(d, theme);
    if (color)
      return color;
  }]
];

// src/rules/size.ts
var sizes = [
  ["w-full", { width: "100%" }],
  ["h-full", { height: "100%" }],
  ["w-screen", { width: "100vw" }],
  ["h-screen", { height: "100vh" }],
  ["max-w-none", { "max-width": "none" }],
  ["max-w-full", { "max-width": "100%" }],
  ["max-w-screen", { "max-width": "100vw" }],
  ["min-w-none", { "min-width": "none" }],
  ["min-w-full", { "min-width": "100%" }],
  ["min-w-screen", { "min-width": "100vw" }],
  ["max-h-none", { "max-height": "none" }],
  ["max-h-full", { "max-height": "100%" }],
  ["max-h-screen", { "max-height": "100vh" }],
  ["min-h-none", { "min-height": "none" }],
  ["min-h-full", { "min-height": "100%" }],
  ["min-h-screen", { "min-height": "100vh" }],
  [/^(((min|max)-)?(w|h))-([^-]+)$/, ([, , , m, w, s]) => ({ [getPropName(m, w)]: handler.bracket.fraction.rem(s) })],
  [/^(((min|max)-)?(w))-screen-([a-z]+)$/, ([, , , m, w, s], { theme }) => {
    var _a;
    const v = (_a = theme.breakpoints) == null ? void 0 : _a[s];
    if (v != null)
      return { [getPropName(m, w)]: v };
  }]
];
function getPropName(minmax, hw) {
  var _a;
  const minMaxMap = {
    w: "width",
    h: "height",
    min: "min-",
    max: "max-"
  };
  return `${(_a = minMaxMap[minmax]) != null ? _a : ""}${minMaxMap[hw]}`;
}

// src/rules/spacing.ts
var directionSize = (prefix) => ([_, direction, size]) => {
  const v = handler.bracket.rem.fraction.cssvar(size);
  if (v)
    return directionMap[direction].map((i) => [prefix + i, v]);
};
var paddings = [
  [/^pa?()-?(-?.+)$/, directionSize("padding")],
  [/^p-?([xy])-?(-?.+)$/, directionSize("padding")],
  [/^p-?([rltbse])-?(-?.+)$/, directionSize("padding")]
];
var margins = [
  [/^ma?()-?(-?.+)$/, directionSize("margin")],
  [/^m-?([xy])-?(-?.+)$/, directionSize("margin")],
  [/^m-?([rltbse])-?(-?.+)$/, directionSize("margin")],
  [/^space-?([xy])-?(-?.+)$/, (match) => {
    var _a;
    const [, direction, size] = match;
    if (size === "reverse")
      return { [`--un-space-${direction}-reverse`]: 1 };
    const results = (_a = directionSize("margin")(match)) == null ? void 0 : _a.map((item) => {
      const value = item[0].endsWith("right") || item[0].endsWith("bottom") ? `calc(${item[1]} * var(--un-space-${direction}-reverse))` : `calc(${item[1]} * calc(1 - var(--un-space-${direction}-reverse)))`;
      return [item[0], value];
    });
    if (results) {
      return [
        [`--un-space-${direction}-reverse`, 0],
        ...results
      ];
    }
  }]
];

// src/rules/static.ts
var displays = [
  ["inline", { display: "inline" }],
  ["block", { display: "block" }],
  ["inline-block", { display: "inline-block" }],
  ["contents", { display: "contents" }],
  ["flow-root", { display: "flow-root" }],
  ["list-item", { display: "list-item" }],
  ["hidden", { display: "none" }]
];
var appearances = [
  ["visible", { visibility: "visible" }],
  ["invisible", { visibility: "hidden" }],
  ["backface-visible", { "backface-visibility": "visible" }],
  ["backface-hidden", { "backface-visibility": "hidden" }]
];
var cursors = [
  [/^cursor-(.+)$/, ([, c]) => ({ cursor: c })]
];
var pointerEvents = [
  ["pointer-events-none", { "pointer-events": "none" }],
  ["pointer-events-auto", { "pointer-events": "auto" }]
];
var resizes = [
  ["resize-none", { resize: "none" }],
  ["resize-x", { resize: "horizontal" }],
  ["resize-y", { resize: "vertical" }],
  ["resize", { resize: "both" }]
];
var userSelects = [
  [/^select-(none|text|all|auto)$/, ([, v]) => ({ "user-select": v })]
];
var whitespaces = [
  [/^(?:whitespace|ws)-(normal|nowrap|pre|pre-line|pre-wrap)$/, ([, v]) => ({ "white-space": v })]
];
var breaks = [
  ["break-normal", { "overflow-wrap": "normal", "word-break": "normal" }],
  ["break-works", { "overflow-wrap": "break-word" }],
  ["break-all", { "word-break": "break-all" }]
];
var textOverflows = [
  ["truncate", { "overflow": "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }],
  ["text-ellipsis", { "text-overflow": "ellipsis" }],
  ["text-clip", { "text-overflow": "clip" }]
];
var textTransforms = [
  ["case-upper", { "text-transform": "uppercase" }],
  ["case-lower", { "text-transform": "lowercase" }],
  ["case-capital", { "text-transform": "capitalize" }],
  ["case-normal", { "text-transform": "none" }]
];
var textDecorations = [
  ["underline", { "text-decoration": "underline" }],
  ["line-through", { "text-decoration": "line-through" }],
  ["no-underline", { "text-decoration": "none" }]
];
var textDecorationStyles = [
  ["underline-solid", { "text-decoration-style": "solid" }],
  ["underline-double", { "text-decoration-style": "double" }],
  ["underline-dotted", { "text-decoration-style": "dotted" }],
  ["underline-dashed", { "text-decoration-style": "dashed" }]
];
var fontStyles = [
  ["italic", { "font-style": "italic" }],
  ["not-italic", { "font-style": "normal" }]
];
var fontSmoothings = [
  ["antialiased", {
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "font-smoothing": "grayscale"
  }],
  ["subpixel-antialiased", {
    "-webkit-font-smoothing": "auto",
    "-moz-osx-font-smoothing": "auto",
    "font-smoothing": "auto"
  }]
];
var hyphens = [
  ["hyphens-none", {
    "-webkit-hyphens": "none",
    "-ms-hyphens": "none",
    "hyphens": "none"
  }],
  ["hyphens-manual", {
    "-webkit-hyphens": "manual",
    "-ms-hyphens": "manual",
    "hyphens": "manual"
  }],
  ["hyphens-auto", {
    "-webkit-hyphens": "auto",
    "-ms-hyphens": "auto",
    "hyphens": "auto"
  }]
];
var writingModes = [
  ["write-normal", { "writing-mode": "horizontal-tb" }],
  ["write-vertical-right", { "writing-mode": "vertical-rl" }],
  ["write-vertical-left", { "writing-mode": "vertical-lr" }]
];
var writingOrientations = [
  ["write-orient-mixed", { "text-orientation": "mixed" }],
  ["write-orient-upright", { "text-orientation": "upright" }],
  ["write-orient-sideways", { "text-orientation": "sideways" }]
];
var screenReadersAccess = [
  [
    "sr-only",
    {
      "position": "absolute",
      "width": "1px",
      "height": "1px",
      "padding": "0",
      "margin": "-1px",
      "overflow": "hidden",
      "clip": "rect(0,0,0,0)",
      "white-space": "nowrap",
      "border-width": 0
    }
  ],
  [
    "not-sr-only",
    {
      "position": "static",
      "width": "auto",
      "height": "auto",
      "padding": "0",
      "margin": "0",
      "overflow": "visible",
      "clip": "auto",
      "white-space": "normal"
    }
  ]
];

// src/rules/table.ts
var tables = [
  ["border-collapse", { "border-collapse": "collapse" }],
  ["border-separate", { "border-collapse": "separate" }],
  ["caption-top", { "caption-side": "top" }],
  ["caption-bottom", { "caption-side": "bottom" }],
  ["inline-table", { display: "inline-table" }],
  ["table", { display: "table" }],
  ["table-auto", { "table-layout": "auto" }],
  ["table-empty-cells-visible", { "empty-cells": "show" }],
  ["table-empty-cells-hidden", { "empty-cells": "hide" }],
  ["table-fixed", { "table-layout": "fixed" }],
  ["table-caption", { display: "table-caption" }],
  ["table-cell", { display: "table-cell" }],
  ["table-column", { display: "table-column" }],
  ["table-column-group", { display: "table-column-group" }],
  ["table-footer-group", { display: "table-footer-group" }],
  ["table-header-group", { display: "table-header-group" }],
  ["table-row", { display: "table-row" }],
  ["table-row-group", { display: "table-row-group" }]
];

// src/rules/transform.ts
var transforms = [
  [
    "transform",
    {
      "--un-rotate": 0,
      "--un-scale-x": 1,
      "--un-scale-y": 1,
      "--un-scale-z": 1,
      "--un-skew-x": 0,
      "--un-skew-y": 0,
      "--un-translate-x": 0,
      "--un-translate-y": 0,
      "--un-translate-z": 0,
      "transform": "rotate(var(--un-rotate)) scaleX(var(--un-scale-x)) scaleY(var(--un-scale-y)) scaleZ(var(--un-scale-z)) skewX(var(--un-skew-x)) skewY(var(--un-skew-y)) translateX(var(--un-translate-x)) translateY(var(--un-translate-y)) translateZ(var(--un-translate-z))"
    }
  ],
  [/^preserve-(3d|flat)$/, ([, value]) => ({
    "transform-style": value === "3d" ? `preserve-${value}` : value
  })],
  [/^translate()-([^-]+)$/, handleTranslate],
  [/^translate-([xyz])-([^-]+)$/, handleTranslate],
  [/^scale()-([^-]+)$/, handleScale],
  [/^scale-([xyz])-([^-]+)$/, handleScale],
  [/^rotate-([^-]+)(?:deg)?$/, handleRotate],
  ["origin-center", { "transform-origin": "center" }],
  ["origin-top", { "transform-origin": "top" }],
  ["origin-top-right", { "transform-origin": "top right" }],
  ["origin-right", { "transform-origin": "right" }],
  ["origin-bottom-right", { "transform-origin": "bottom right" }],
  ["origin-bottom", { "transform-origin": "bottom" }],
  ["origin-bottom-left", { "transform-origin": "bottom left" }],
  ["origin-left", { "transform-origin": "left" }],
  ["origin-top-left", { "transform-origin": "top left" }]
];
function handleTranslate([, d, b]) {
  const v = handler.bracket.fraction.rem(b);
  if (v != null) {
    return [
      ...xyzMap[d].map((i) => [`--un-translate${i}`, v])
    ];
  }
}
function handleScale([, d, b]) {
  const v = handler.bracket.fraction.percent(b);
  if (v != null) {
    return [
      ...xyzMap[d].map((i) => [`--un-scale${i}`, v])
    ];
  }
}
function handleRotate([, b]) {
  const v = handler.bracket.number(b);
  if (v != null)
    return { "--un-rotate": `${v}deg` };
}

// src/rules/behaviors.ts
var outlineStyle = ["none", "auto", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset", "inherit", "initial", "revert", "unset"];
var listStyleProps = ["none", "disc", "circle", "square", "decimal", "zero-decimal", "greek", "roman", "upper-roman", "alpha", "upper-alpha"];
var parseOutlineSize = (s) => {
  const propName = ["width", "offset"].find((item) => s.startsWith(item)) || "width";
  const size = handler.bracket.fraction.rem(s.replace(/^(offset\-|width\-)/, ""));
  if (size) {
    return {
      [`outline-${propName}`]: size
    };
  }
};
var outline = [
  ["outline-none", { "outline": "2px solid transparent", "outline-offset": "2px" }],
  ["outline", { "outline-style": "solid" }],
  [
    /^outline-(.+)$/,
    (match, config) => {
      const [, d] = match;
      if (d === "none") {
        return {
          "outline": "2px solid transparent",
          "outline-offset": "2px"
        };
      }
      if (outlineStyle.includes(d)) {
        return {
          "outline-style": d
        };
      }
      const sizeSheet = parseOutlineSize(d);
      if (sizeSheet)
        return sizeSheet;
      const colorSheet = colorResolver("outline-color", "outline-color")([
        match[0],
        match[1].replace(/^color-/, "")
      ], config);
      if (colorSheet)
        return colorSheet;
    }
  ]
];
var listStyle = [
  [new RegExp(`^list-((${listStyleProps.join("|")})(?:(-outside|-inside))?)$`), ([, value]) => {
    var _a;
    const style = value.split(/-outside|-inside/)[0];
    const position = (_a = /inside|outside/.exec(value)) != null ? _a : [];
    if (position.length) {
      return {
        "list-style-position": `${position[0]}`,
        "list-style-type": `${style}`
      };
    }
    return {
      "list-style-type": `${style}`
    };
  }],
  [/^list-(inside|outside)$/, ([, value]) => {
    return {
      "list-style-position": value
    };
  }]
];
var boxDecorationBreaks = [
  ["decoration-slice", { "box-decoration-break": "slice" }],
  ["decoration-clone", { "box-decoration-break": "clone" }]
];
var caretOpacity = [
  [/^caret-op(?:acity)?-?(.+)$/, ([, d]) => ({ "--un-caret-opacity": handler.bracket.percent(d) })]
];
var caretColors = [
  [/^caret-(.+)$/, colorResolver("caret-color", "caret")]
];
var imageRenderings = [
  ["image-render-auto", { "image-rendering": "auto" }],
  ["image-render-edge", { "image-rendering": "crisp-edges" }],
  ["image-render-pixel", [
    ["-ms-interpolation-mode", "nearest-neighbor"],
    ["image-rendering", "-webkit-optimize-contrast"],
    ["image-rendering", "-moz-crisp-edges"],
    ["image-rendering", "-o-pixelated"],
    ["image-rendering", "pixelated"]
  ]]
];
var appearance = [
  ["appearance-none", {
    "appearance": "none",
    "-webkit-appearance": "none"
  }]
];
var placeholder = [
  [
    /^placeholder-opacity-(\d+)$/,
    ([, d]) => ({
      "placeholder-opacity": handler.bracket.percent(d)
    })
  ],
  [
    /^placeholder-(?!opacity)(.+)$/,
    (match, config) => {
      match[1] = match[1].replace(/^color-/, "");
      return colorResolver("placeholder-color", "placeholder-color")(match, config);
    }
  ]
];
var overflowValues2 = [
  "none",
  "auto",
  "hidden",
  "visible",
  "scroll",
  "contain"
];
var overscrolls = [
  [/^overscroll-(.+)$/, ([, v]) => overflowValues2.includes(v) ? { "overscroll-behavior": v } : void 0],
  [/^overscroll-([xy])-(.+)$/, ([, d, v]) => overflowValues2.includes(v) ? { [`overscroll-behavior-${d}`]: v } : void 0]
];

// src/rules/animation.ts
var keyframes = {
  spin: "@keyframes spin {from {transform:rotate(0deg);} to {transform:rotate(360deg);}}",
  ping: "@keyframes ping {0% {transform:scale(1);opacity:1;} 75%, 100% {transform:scale(2);opacity:0;}}",
  pulse: "@keyframes pulse {0%, 100% {opacity:1;} 50% {opacity:.5;}}",
  bounce: "@keyframes bounce {0%, 100% {transform:translateY(-25%);animation-timing-function:cubic-bezier(0.8,0,1,1);} 50% {transform:translateY(0);animation-timing-function:cubic-bezier(0,0,0.2,1);}}"
};
var animations = [
  [/^animate-(spin|ping|pulse|bounce)$/, ([, name], { constructCSS }) => `${keyframes[name]}
${constructCSS({ animation: `${name} 1s linear infinite` })}`],
  ["animate-none", { animation: "none" }],
  [/^animate(?:-duration)?-((.+)(?:(s|ms)?))$/, ([, d]) => ({ "animation-duration": handler.bracket.time(d.replace(/-duration/, "")) })],
  [/^animate-delay-((.+)(?:(s|ms)?))$/, ([, d]) => ({ "animation-delay": handler.bracket.time(d) })],
  [/^animate-(?:fill-)?mode-(none|forwards|backwards|both|inherit|initial|revert|unset)$/, ([, d]) => ({ "animation-fill-mode": d })],
  [/^animate-(?:direction-)?(normal|reverse|alternate|alternate-reverse|inherit|initial|revert|unset)$/, ([, d]) => ({ "animation-direction": d })],
  [/^animate-(?:iteration-)?count-(.+)$/, ([, d]) => ({ "animation-iteration-count": d.replace(/\-/g, ", ") })],
  [/^animate-name-(.+)/, ([, d]) => ({ "animation-name": d })],
  [/^animate-play(?:-state)?-(paused|running|inherit|initial|revert|unset)$/, ([, d]) => ({ "animation-play-state": d })]
];

// src/rules/variables.ts
var variablesAbbrMap = {
  "w": "width",
  "h": "height",
  "max-w": "max-width",
  "max-h": "max-height",
  "visible": "visibility",
  "select": "user-select",
  "vertical": "vertical-align",
  "backface": "backface-visibility",
  "whitespace": "white-space",
  "break": "word-break",
  "color": "color",
  "case": "text-transform",
  "write": "writing-mode",
  "write-orient": "text-orientation",
  "origin": "transform-origin",
  "bg": "background-color",
  "bg-blend": "background-blend-mode",
  "bg-clip": "-webkit-background-clip",
  "bg-gradient": "linear-gradient",
  "bg-origin-border": "background-origin",
  "bg-position": "background-position",
  "bg-repeat": "background-repeat",
  "bg-size": "background-size",
  "bg-opacity": "background-opacity",
  "tab": "tab-size",
  "underline": "text-decoration-thickness",
  "underline-offset": "text-underline-offset",
  "indent": "text-indent",
  "text": "color",
  "grid-cols": "grid-template-columns",
  "grid-rows": "grid-template-rows",
  "auto-flow": "grid-auto-flow",
  "row-start": "grid-row-start",
  "row-end": "grid-row-end",
  "justify": "justify-content",
  "content": "align-content",
  "items": "align-items",
  "self": "align-self",
  "object": "object-fit",
  "mix-blend": "mix-blend-mode",
  "animate-speed": "animation-speed"
};
var cssVariables = [[
  /^(.+)-\$(.+)$/,
  ([, name, varname]) => {
    const prop = variablesAbbrMap[name];
    if (prop) {
      return {
        [prop]: `var(--${varname})`
      };
    }
  }
]];

// src/rules/question-mark.ts
var questionMark = [
  [
    /^(where|\?)$/,
    (_, { constructCSS, generator }) => {
      if (generator.config.envMode === "dev")
        return `@keyframes __un_qm {0% {box-shadow: inset 4px 4px #ff1e90, inset -4px -4px #ff1e90;} 100% {box-shadow: inset 8px 8px #3399ff, inset -8px -8px #3399ff;}}
${constructCSS({ animation: "__un_qm 0.5s ease-in-out alternate infinite" })}`;
    }
  ]
];

// src/rules/align.ts
var verticalAlignAlias = {
  mid: "middle",
  base: "baseline",
  btm: "bottom"
};
var verticalAligns = [
  [/^(?:vertical|align|v)-(baseline|top|bottom|middle|text-top|text-bottom|mid|base|btm)$/, ([, v]) => ({ "vertical-align": verticalAlignAlias[v] || v })]
];
var textAligns = [
  ["text-center", { "text-align": "center" }],
  ["text-left", { "text-align": "left" }],
  ["text-right", { "text-align": "right" }],
  ["text-justify", { "text-align": "justify" }]
];

// src/rules/index.ts
var rules = [
  screenReadersAccess,
  cssVariables,
  paddings,
  margins,
  displays,
  opacity,
  bgAttachments,
  bgBlendModes,
  bgClips,
  bgColors,
  bgGradients,
  bgImages,
  bgOrigins,
  bgPositions,
  bgSizes,
  bgRepeats,
  borders,
  fonts,
  tabSizes,
  textIndents,
  textOverflows,
  textDecorations,
  textDecorationStyles,
  textDecorationColors,
  textDecorationLengths,
  textDecorationOffsets,
  textStrokeWidths,
  textStrokeColors,
  textTransforms,
  textAligns,
  textColors,
  fontStyles,
  fontSmoothings,
  hyphens,
  writingModes,
  writingOrientations,
  mixBlendModes,
  shadows,
  rings,
  flex,
  grids,
  gaps,
  positions,
  sizes,
  cursors,
  appearances,
  pointerEvents,
  resizes,
  verticalAligns,
  userSelects,
  whitespaces,
  listStyle,
  caretColors,
  boxDecorationBreaks,
  caretOpacity,
  imageRenderings,
  appearance,
  outline,
  placeholder,
  overscrolls,
  breaks,
  trackings,
  leadings,
  overflows,
  positions,
  orders,
  justifies,
  justifyItems,
  justifySelfs,
  alignContents,
  alignItems,
  alignSelfs,
  placeContents,
  placeItems,
  placeSelfs,
  animations,
  insets,
  floats,
  zIndexes,
  objectPositions,
  boxSizing,
  transitions,
  filters,
  tables,
  transforms,
  questionMark
].flat(1);

export {
  rules
};
