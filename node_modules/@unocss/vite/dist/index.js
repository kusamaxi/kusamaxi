var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  ChunkModeBuildPlugin: () => ChunkModeBuildPlugin,
  GlobalModeBuildPlugin: () => GlobalModeBuildPlugin,
  GlobalModeDevPlugin: () => GlobalModeDevPlugin,
  GlobalModePlugin: () => GlobalModePlugin,
  PerModuleModePlugin: () => PerModuleModePlugin,
  VueScopedPlugin: () => VueScopedPlugin,
  default: () => UnocssPlugin
});
var import_core2 = __toModule(require("@unocss/core"));
var import_config2 = __toModule(require("@unocss/config"));
var import_inspector = __toModule(require("@unocss/inspector"));

// src/context.ts
var import_core = __toModule(require("@unocss/core"));
function createContext(uno, config, configFilepath) {
  const invalidations = [];
  const modules = new import_core.BetterMap();
  const tokens = new Set();
  function invalidate() {
    invalidations.forEach((cb) => cb());
  }
  async function scan(code, id) {
    if (id)
      modules.set(id, code);
    await uno.applyExtractors(code, id, tokens);
    invalidate();
  }
  return {
    tokens,
    modules,
    invalidate,
    onInvalidate(fn) {
      invalidations.push(fn);
    },
    uno,
    scan,
    config,
    configFilepath
  };
}

// src/modes/chunk-build.ts
var import_pluginutils = __toModule(require("@rollup/pluginutils"));

// src/utils.ts
var import_crypto = __toModule(require("crypto"));
var defaultExclude = [/[\/\\]node_modules[\/\\]/, /[\/\\]dist[\/\\]/, /\.(css|postcss|sass|scss|less|stylus|styl)$/];
var defaultInclude = [/\.vue$/, /\.vue\?vue/, /\.svelte$/, /\.[jt]sx$/, /\.mdx?$/, /\.astro$/];
function getHash(input, length = 8) {
  return (0, import_crypto.createHash)("sha256").update(input).digest("hex").substr(0, length);
}
function getPath(id) {
  return id.replace(/\?.*$/, "");
}

// src/modes/chunk-build.ts
function ChunkModeBuildPlugin({ uno, config }) {
  let cssPlugin;
  const filter = (0, import_pluginutils.createFilter)(config.include || defaultInclude, config.exclude || defaultExclude);
  const files = {};
  return {
    name: "unocss:chunk",
    apply: "build",
    enforce: "pre",
    configResolved(config2) {
      cssPlugin = config2.plugins.find((i) => i.name === "vite:css-post");
    },
    transform(code, id) {
      if (!filter(id))
        return;
      files[id] = code;
      return null;
    },
    async renderChunk(_, chunk) {
      const chunks = Object.keys(chunk.modules).map((i) => files[i]).filter(Boolean);
      if (!chunks.length)
        return null;
      const tokens = new Set();
      await Promise.all(chunks.map((c) => uno.applyExtractors(c, void 0, tokens)));
      const { css } = await uno.generate(tokens);
      const fakeCssId = `${chunk.fileName}.css`;
      await cssPlugin.transform(css, fakeCssId);
      chunk.modules[fakeCssId] = {
        code: null,
        originalLength: 0,
        removedExports: [],
        renderedExports: [],
        renderedLength: 0
      };
      return null;
    },
    async transformIndexHtml(code) {
      const { css } = await uno.generate(code);
      if (css)
        return `${code}<style>${css}</style>`;
    }
  };
}

// src/modes/global/build.ts
var import_pluginutils2 = __toModule(require("@rollup/pluginutils"));

// src/modes/global/shared.ts
var READY_CALLBACK_DEFAULT = "/__unocss_ready";
var ALL_LAYERS = "__ALL__";
var VIRTUAL_ENTRY_ALIAS = [
  /^(?:virtual:)?uno(?::(.+))?\.css(\?.*)?$/
];
function resolveId(id) {
  for (const alias of VIRTUAL_ENTRY_ALIAS) {
    const match = id.match(alias);
    if (match) {
      return match[1] ? {
        id: `/__uno_${match[1]}.css`,
        layer: match[1]
      } : {
        id: "/__uno.css",
        layer: ALL_LAYERS
      };
    }
  }
}

// src/modes/global/build.ts
var PLACEHOLDER_RE = /#--unocss--\s*{\s*layer\s*:\s*(.+?);?\s*}/g;
function GlobalModeBuildPlugin({ uno, config, scan, tokens }) {
  const filter = (0, import_pluginutils2.createFilter)(config.include || defaultInclude, config.exclude || defaultExclude);
  const tasks = [];
  const entries = new Map();
  return [
    {
      name: "unocss:global:build:scan",
      apply: "build",
      enforce: "pre",
      transform(code, id) {
        if (filter(id))
          tasks.push(scan(code, id));
        return null;
      },
      transformIndexHtml: {
        enforce: "pre",
        transform(code, { filename }) {
          tasks.push(scan(code, filename));
        }
      },
      resolveId(id) {
        const entry = resolveId(id);
        if (entry) {
          entries.set(entry.id, entry.layer);
          return entry.id;
        }
      },
      async load(id) {
        const layer = entries.get(getPath(id));
        if (layer)
          return `#--unocss--{layer:${layer}}`;
      }
    },
    {
      name: "unocss:global:build:generate",
      apply(options, { command }) {
        var _a;
        return command === "build" && !((_a = options.build) == null ? void 0 : _a.ssr);
      },
      enforce: "post",
      async generateBundle(options, bundle) {
        const files = Object.keys(bundle).filter((i) => i.endsWith(".css"));
        if (!files.length)
          return;
        await Promise.all(tasks);
        const result = await uno.generate(tokens, { layerComments: false });
        let replaced = false;
        for (const file of files) {
          const chunk = bundle[file];
          if (chunk.type === "asset" && typeof chunk.source === "string") {
            chunk.source = chunk.source.replace(PLACEHOLDER_RE, (_, layer) => {
              replaced = true;
              if (layer === ALL_LAYERS)
                return result.getLayers(Array.from(entries.values()));
              else
                return result.getLayer(layer) || "";
            });
          }
        }
        if (!replaced)
          this.error(new Error("[unocss] does not found CSS placeholder in the generated chunks,\nthis is likely an internal bug of unocss vite plugin"));
      }
    }
  ];
}

// src/modes/global/dev.ts
var import_pluginutils3 = __toModule(require("@rollup/pluginutils"));
var WARN_TIMEOUT = 2e3;
function GlobalModeDevPlugin({ config, uno, tokens, onInvalidate, scan }) {
  const servers = [];
  const filter = (0, import_pluginutils3.createFilter)(config.include || defaultInclude, config.exclude || defaultExclude);
  const tasks = [];
  const entries = new Map();
  let invalidateTimer;
  let lastUpdate = Date.now();
  let lastServed = 0;
  let resolved = false;
  let resolvedWarnTimer;
  function invalidate(timer = 10) {
    for (const server of servers) {
      for (const id of entries.keys()) {
        const mod = server.moduleGraph.getModuleById(id);
        if (!mod)
          continue;
        lastUpdate = Date.now();
        server.moduleGraph.invalidateModule(mod);
      }
    }
    clearTimeout(invalidateTimer);
    invalidateTimer = setTimeout(sendUpdate, timer);
  }
  function sendUpdate() {
    for (const server of servers) {
      server.ws.send({
        type: "update",
        updates: Array.from(entries.keys()).map((i) => ({
          acceptedPath: i,
          path: i,
          timestamp: lastUpdate,
          type: "js-update"
        }))
      });
    }
  }
  function setWarnTimer() {
    if (!resolved && !resolvedWarnTimer) {
      resolvedWarnTimer = setTimeout(() => {
        if (!resolved) {
          const msg = "[unocss] entry module not found, have you add `import 'uno.css'` in your main entry?";
          console.warn(msg);
          servers.forEach(({ ws }) => ws.send({
            type: "error",
            err: { message: msg, stack: "" }
          }));
        }
      }, WARN_TIMEOUT);
    }
  }
  onInvalidate(invalidate);
  return [
    {
      name: "unocss:global",
      apply: "serve",
      enforce: "pre",
      configureServer(_server) {
        servers.push(_server);
        _server.middlewares.use(async (req, res, next) => {
          var _a;
          setWarnTimer();
          if ((_a = req.url) == null ? void 0 : _a.startsWith(READY_CALLBACK_DEFAULT)) {
            const servedTime = +req.url.slice(READY_CALLBACK_DEFAULT.length + 1);
            if (servedTime < lastUpdate)
              invalidate(0);
            res.statusCode = 200;
            res.end();
          } else {
            return next();
          }
        });
      },
      transform(code, id) {
        if (filter(id))
          scan(code, id);
        return null;
      },
      transformIndexHtml: {
        enforce: "pre",
        transform(code, { filename }) {
          scan(code, filename);
        }
      },
      resolveId(id) {
        const entry = resolveId(id);
        if (entry) {
          resolved = true;
          entries.set(entry.id, entry.layer);
          return entry.id;
        }
      },
      async load(id) {
        const layer = entries.get(getPath(id));
        if (!layer)
          return null;
        await Promise.all(tasks);
        const result = await uno.generate(tokens);
        lastServed = Date.now();
        if (layer === ALL_LAYERS)
          return result.getLayers(Array.from(entries.values()));
        else
          return result.getLayer(layer);
      }
    },
    {
      name: "unocss:global:post",
      apply(config2, env) {
        var _a;
        return env.command === "serve" && !((_a = config2.build) == null ? void 0 : _a.ssr);
      },
      enforce: "post",
      transform(code, id) {
        if (entries.has(getPath(id)) && code.includes("import.meta.hot"))
          return `${code}
await fetch("${READY_CALLBACK_DEFAULT}/${lastServed}")`;
      }
    }
  ];
}

// src/modes/global/index.ts
function GlobalModePlugin(ctx) {
  return [
    ...GlobalModeBuildPlugin(ctx),
    ...GlobalModeDevPlugin(ctx)
  ];
}

// src/modes/per-module.ts
var import_pluginutils4 = __toModule(require("@rollup/pluginutils"));
var VIRTUAL_PREFIX = "/@unocss/";
var SCOPE_IMPORT_RE = / from (['"])(@unocss\/scope)\1/;
function PerModuleModePlugin({ uno, config }) {
  const moduleMap = new Map();
  let server;
  const filter = (0, import_pluginutils4.createFilter)(config.include || defaultInclude, config.exclude || defaultExclude);
  const invalidate = (hash) => {
    if (!server)
      return;
    const id = `${VIRTUAL_PREFIX}${hash}.css`;
    const mod = server.moduleGraph.getModuleById(id);
    if (!mod)
      return;
    server.moduleGraph.invalidateModule(mod);
    server.ws.send({
      type: "update",
      updates: [{
        acceptedPath: id,
        path: id,
        timestamp: +Date.now(),
        type: "js-update"
      }]
    });
  };
  return {
    name: "unocss:module-scope",
    enforce: "post",
    configureServer(_server) {
      server = _server;
    },
    async transform(code, id) {
      if (!filter(id))
        return;
      const hash = getHash(id);
      const hasScope = code.match(SCOPE_IMPORT_RE);
      const { css } = await uno.generate(code, { id, scope: hasScope ? `.${hash}` : void 0, preflights: false });
      if (!css && !hasScope)
        return null;
      if (hasScope)
        code = code.replace(SCOPE_IMPORT_RE, ` from 'data:text/javascript;base64,${Buffer.from(`export default () => "${hash}"`).toString("base64")}'`);
      moduleMap.set(hash, [id, css]);
      invalidate(hash);
      return {
        code: `import "${VIRTUAL_PREFIX}${hash}.css";${code}`,
        map: null
      };
    },
    resolveId(id) {
      return id.startsWith(VIRTUAL_PREFIX) ? id : null;
    },
    load(id) {
      if (!id.startsWith(VIRTUAL_PREFIX))
        return null;
      const hash = id.slice(VIRTUAL_PREFIX.length, -".css".length);
      const [source, css] = moduleMap.get(hash) || [];
      if (source)
        this.addWatchFile(source);
      return `
/* unocss ${source} */
${css}`;
    }
  };
}

// src/modes/vue-scoped.ts
var import_pluginutils5 = __toModule(require("@rollup/pluginutils"));
function VueScopedPlugin({ uno, config }) {
  const filter = (0, import_pluginutils5.createFilter)(config.include || [/\.vue$/], config.exclude || defaultExclude);
  async function transformSFC(code) {
    const { css } = await uno.generate(code);
    if (!css)
      return null;
    return `${code}
<style scoped>${css}</style>`;
  }
  return {
    name: "unocss:vue-scoped",
    enforce: "pre",
    transform(code, id) {
      if (!filter(id))
        return;
      return transformSFC(code);
    },
    handleHotUpdate(ctx) {
      const read = ctx.read;
      if (filter(ctx.file)) {
        ctx.read = async () => {
          const code = await read();
          return await transformSFC(code) || code;
        };
      }
    }
  };
}

// src/config-hmr.ts
var import_config = __toModule(require("@unocss/config"));
function ConfigHMRPlugin({ uno, configFilepath: filepath, invalidate, tokens, modules }) {
  return {
    name: "unocss:config",
    configureServer(server) {
      uno.config.envMode = "dev";
      if (!filepath)
        return;
      server.watcher.add(filepath);
      server.watcher.on("change", async (p) => {
        if (p !== filepath)
          return;
        uno.setConfig((0, import_config.loadConfig)(filepath).config);
        uno.config.envMode = "dev";
        tokens.clear();
        await Promise.all(modules.map((code, id) => uno.applyExtractors(code, id, tokens)));
        invalidate();
      });
    }
  };
}

// src/index.ts
function UnocssPlugin(configOrPath, defaults = {}) {
  var _a;
  const { config = {}, filepath } = (0, import_config2.loadConfig)(configOrPath);
  const mode = (_a = config.mode) != null ? _a : "global";
  const uno = (0, import_core2.createGenerator)(config, defaults);
  const ctx = createContext(uno, config, filepath);
  const plugins = [
    ConfigHMRPlugin(ctx)
  ];
  if (config.inspector !== false)
    plugins.push((0, import_inspector.default)(ctx));
  if (mode === "per-module") {
    plugins.push(PerModuleModePlugin(ctx));
  } else if (mode === "vue-scoped") {
    plugins.push(VueScopedPlugin(ctx));
  } else if (mode === "global") {
    plugins.push(...GlobalModePlugin(ctx));
  } else if (mode === "dist-chunk") {
    plugins.push(ChunkModeBuildPlugin(ctx), ...GlobalModeDevPlugin(ctx));
  } else {
    throw new Error(`[unocss] unknown mode "${mode}"`);
  }
  return plugins.filter(Boolean);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChunkModeBuildPlugin,
  GlobalModeBuildPlugin,
  GlobalModeDevPlugin,
  GlobalModePlugin,
  PerModuleModePlugin,
  VueScopedPlugin
});
